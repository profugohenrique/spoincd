# -*- coding: utf-8 -*-
"""INCDChurn.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F0sWFrne34Zld6hy3qw5gVY_w2g6IDgE
"""

# ============================================================
# Bloco 0 - Setup inicial
# ============================================================

# Instalar bibliotecas (se necessário no Colab)
# !pip install pandas scikit-learn matplotlib seaborn

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import (
    confusion_matrix, accuracy_score, precision_score, recall_score, f1_score,
    roc_curve, roc_auc_score, classification_report
)

# ============================================================
# Bloco 1 - Carregamento do dataset
# ============================================================

# Dataset: Telco Customer Churn (público disponível no Kaggle/IBM)
# Link original: https://www.kaggle.com/blastchar/telco-customer-churn

url = "https://raw.githubusercontent.com/IBM/telco-customer-churn-on-icp4d/master/data/Telco-Customer-Churn.csv"
df = pd.read_csv(url)

# Visualizar primeiras linhas
df.head()

# ============================================================
# Bloco 2 - Exploração e pré-processamento
# ============================================================

# Remover colunas irrelevantes
df = df.drop(columns=['customerID'])

# Converter 'TotalCharges' para numérico
df['TotalCharges'] = pd.to_numeric(df['TotalCharges'], errors='coerce')
df['TotalCharges'].fillna(df['TotalCharges'].median(), inplace=True)

# Variável alvo: "Churn" (Yes/No → 1/0)
df['Churn'] = df['Churn'].map({'Yes':1, 'No':0})

# Separar variáveis numéricas e categóricas
cat_cols = df.select_dtypes(include=['object']).columns
num_cols = df.select_dtypes(include=['int64','float64']).columns

# One-hot encoding para categóricas
df_encoded = pd.get_dummies(df, columns=cat_cols, drop_first=True)

# Divisão treino/teste
X = df_encoded.drop("Churn", axis=1)
y = df_encoded["Churn"]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42, stratify=y)

# Padronização
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

df_encoded.shape

# ============================================================
# Bloco 3 - Treinamento do Modelo
# ============================================================

logreg = LogisticRegression(max_iter=1000, solver='liblinear')
logreg.fit(X_train, y_train)

# Predições
y_pred = logreg.predict(X_test)
y_pred_proba = logreg.predict_proba(X_test)[:,1]

# Avaliação inicial
print("Acurácia:", accuracy_score(y_test, y_pred))
print("Precisão:", precision_score(y_test, y_pred))
print("Recall:", recall_score(y_test, y_pred))
print("F1:", f1_score(y_test, y_pred))

print("\nRelatório de Classificação:\n", classification_report(y_test, y_pred))

# ============================================================
# Bloco 4 - Matriz de Confusão
# ============================================================

cm = confusion_matrix(y_test, y_pred)
sns.heatmap(cm, annot=True, fmt="d", cmap="Blues", xticklabels=["Não Churn","Churn"], yticklabels=["Não Churn","Churn"])
plt.xlabel("Previsto")
plt.ylabel("Real")
plt.title("Matriz de Confusão")
plt.show()

# ============================================================
# Bloco 5 - Curva ROC & AUC
# ============================================================

fpr, tpr, thresholds = roc_curve(y_test, y_pred_proba)
auc = roc_auc_score(y_test, y_pred_proba)

plt.plot(fpr, tpr, label=f"AUC = {auc:.3f}")
plt.plot([0,1],[0,1],'k--')
plt.xlabel("Taxa de Falsos Positivos")
plt.ylabel("Taxa de Verdadeiros Positivos")
plt.title("Curva ROC")
plt.legend()
plt.show()

# ============================================================
# Bloco 6 - Análise de Thresholds
# ============================================================

thresholds_list = [0.3, 0.5, 0.7]

for t in thresholds_list:
    y_pred_custom = (y_pred_proba >= t).astype(int)
    print(f"\nThreshold = {t}")
    print("Acurácia:", accuracy_score(y_test, y_pred_custom))
    print("Precisão:", precision_score(y_test, y_pred_custom))
    print("Recall:", recall_score(y_test, y_pred_custom))
    print("F1:", f1_score(y_test, y_pred_custom))